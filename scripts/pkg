#!/usr/bin/env bash
set -e

main() {
	case "$1" in
	"list")
		pkg::list
		;;
	"update")
		shift
		if [[ "$1" == "" ]]; then
			echo "Usage: $0 update <package> [commit]" >&2
			return 1
		fi
		pkg::update "$@"
		;;
	""|"-h"|"--help")
		echo "Usage: $0 {list|update}"
		;;
	*)
		echo "Unknown argument: $1"
		return 1;;
	esac
}

pkg::list() {
	nix-instantiate --eval --json \
		-E 'builtins.attrNames (import ./packages {})' \
		| jq -r '.[]'
}

pkg::update() {
	local package="$1"
	local nivFlags=()

	case "$2" in
	"v"*)
		nivFlags+=(-v "$2");;
	"refs/tags/"*|[0-9a-f]*)
		nivFlags+=(-r "$2" -v "");;
	"refs/heads/"*)
		nivFlags+=(-b "$2" -v "");;
	"latest"|"")
		nivFlags+=(-v "");;
	*)
		echo "Unknown version or ref or \`latest'" >&2
		exit 1;;
	esac

	niv update "$package" "${nivFlags[@]}" >&2

	(
		cd packages

		# Fix nix-update being incompetent at figuring out where the source file
		# is. We always use the callPackage <file> pattern, so we can just
		# regex-search that.
		src=$(sed -n 's/.*'"$package"'\s*=.*callPackage \(.*\) {.*}.*/\1/p' default.nix)
		if [[ ! "$src" ]]; then
			echo "Failed to find callPackage for $package" >&2
			exit 1
		fi

		# If we're importing a directory, then add the trailing filename.
		if [[ -d "$src" ]]; then
			src="$src/default.nix"
		fi

		echo "Source: $src"
		echo "Package: $package"

		nix-update --version=skip "$package" --override-filename "$src" >&2
	)
}

# Only run main if this script is not being sourced as a library.
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
	main "$@"
fi
